// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String   @id @default(uuid())
  firstName             String
  lastName              String
  email                 String   @unique
  password              String
  role                  Role
  phone                 String?
  teamId                String?
  companyId             String?
  isSuspended           Boolean  @default(false)
  preferredLanguage     String   @default("en")
  createdAt             DateTime @default(now())
  createdById           String?
  
  // Relations
  team                  Team?    @relation(fields: [teamId], references: [id])
  company               Company? @relation("CompanyEmployees", fields: [companyId], references: [id])
  notifications         Notification[]
  
  // Self-relations for hierarchical structure
  projectManagerId      String?
  groupLeaderId         String?
  responsibleTesterId   String?

  managedGroupLeaders   User[] @relation("ProjectManagerLeads")
  projectManager        User?  @relation("ProjectManagerLeads", fields: [projectManagerId], references: [id])
  
  managedDevelopers     User[] @relation("GroupLeaderLeads")
  groupLeader           User?  @relation("GroupLeaderLeads", fields: [groupLeaderId], references: [id])
  
  managedTesters        User[] @relation("ResponsibleTesterLeads")
  responsibleTester     User?  @relation("ResponsibleTesterLeads", fields: [responsibleTesterId], references: [id])
  
  createdUsers          User[] @relation("UserCreatedBy")
  createdBy             User?  @relation("UserCreatedBy", fields: [createdById], references: [id])

  // Relations to Ticket, TestTask, and Task models
  assignedTickets       Ticket[] @relation("AssignedTo")
  createdTickets        Ticket[] @relation("CreatedBy")
  agentTickets          Ticket[] @relation("Agent")
  
  assignedTestTasks     TestTask[] @relation("AssignedToTestTask")
  createdTestTasks      TestTask[] @relation("CreatedByTestTask")
  responsibleTestTasks  TestTask[] @relation("ResponsibleTesterTestTask")

  assignedTasks         Task[] @relation("AssignedToTask")
  createdTasks          Task[] @relation("CreatedByTask")
  
  // Relations to Comment, Blocker, and History
  comments              Comment[]
  taskComments          TaskComment[]
  testTaskComments      TestTaskComment[]
  testTaskBlockers      TestTaskBlocker[]
  taskBlockers          TaskBlocker[] @relation("TaskBlockerReportedBy")
  taskHistories         TaskHistory[] @relation("TaskHistoryPerformedBy")
  
  // New Relations to Company
  companiesCreated      Company[] @relation("CompanyCreatedBy")
  companiesCommercial   Company[] @relation("CompanyCommercialAgent")
  uploadedDocuments     Document[]

  @@map("users")
}

model Team {
  id      String @id @default(uuid())
  name    String @unique
  members User[]

  @@map("teams")
}

model Company {
  id            String          @id @default(uuid())
  name          String          @unique
  billingMethod BillingMethod
  
  // Relations
  addressId           String?   @unique
  address             Address?  @relation(fields: [addressId], references: [id])
  contactPersonId     String?   @unique
  contactPerson       ContactPerson? @relation(fields: [contactPersonId], references: [id])
  commercialAgentId   String?
  commercialAgent     User?     @relation("CompanyCommercialAgent", fields: [commercialAgentId], references: [id])
  createdById         String?
  createdBy           User?     @relation("CompanyCreatedBy", fields: [createdById], references: [id])

  employees           User[]    @relation("CompanyEmployees")
  tickets             Ticket[]
  contacts            Contact[]
  availabilitySlots   AvailabilitySlot[]
  documents           Document[]

  @@map("companies")
}

model Address {
  id        String @id @default(uuid())
  street    String
  city      String
  state     String?
  zipCode   String
  country   String

  company   Company?

  @@map("addresses")
}

model ContactPerson {
  id        String  @id @default(uuid())
  name      String
  position  String?
  email     String
  phone     String?
  company   Company?
  
  @@map("contact_persons")
}

model Contact {
  id        String  @id @default(uuid())
  name      String?
  email     String?
  phone     String?
  isPrimary Boolean @default(false)
  
  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  @@map("contacts")
}

model AvailabilitySlot {
  id        String         @id @default(uuid())
  day       AvailabilityDay
  startTime String // HH:MM
  endTime   String // HH:MM

  companyId String
  company   Company @relation(fields: [companyId], references: [id])

  @@map("availability_slots")
}

model Document {
  id           String   @id @default(uuid())
  name         String
  fileType     String
  filePath     String
  uploadedById String?
  uploadedAt   DateTime @default(now())
  
  companyId    String
  company      Company  @relation(fields: [companyId], references: [id])
  uploadedBy   User?    @relation(fields: [uploadedById], references: [id])

  @@map("documents")
}

model Project {
  id          String   @id @default(uuid())
  name        String
  description String?

  // Relations
  tickets     Ticket[]
  tasks       Task[]

  @@map("projects")
}

model Notification {
  id                String   @id @default(uuid())
  message           String
  isRead            Boolean  @default(false)
  createdAt         DateTime @default(now())
  
  // A notification is related to a user
  user              User     @relation(fields: [userId], references: [id])
  userId            String

  relatedToId       String
  relatedToModel    String // This will store the name of the related model, e.g., "Ticket", "Intervention"
  
  @@map("notifications")
}

model Ticket {
  id           String         @id @default(uuid())
  title        String
  description  String?
  type         TicketType
  status       TicketStatus
  priority     TicketPriority
  resolution   String?
  ticketId     String         @unique @default(cuid()) // Unique human-readable ID
  
  attachments  String[]
  closedAt     DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  // Relations
  projectId    String?
  companyId    String?
  assignedToId String?
  createdById  String?
  agentId      String?

  project      Project?       @relation(fields: [projectId], references: [id])
  company      Company?       @relation(fields: [companyId], references: [id])
  assignedTo   User?          @relation("AssignedTo", fields: [assignedToId], references: [id])
  createdBy    User?          @relation("CreatedBy", fields: [createdById], references: [id])
  agent        User?          @relation("Agent", fields: [agentId], references: [id])
  comments     Comment[]
  history      HistoryItem[]
  
  // New relation to TestTask
  testTasks    TestTask[]
  tasks        Task[]

  @@map("tickets")
}

model Comment {
  id        String   @id @default(uuid())
  text      String
  createdAt DateTime @default(now())
  
  // Relations
  ticketId  String
  userId    String

  ticket    Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("comments")
}

model HistoryItem {
  id         String   @id @default(uuid())
  action     String
  createdAt  DateTime @default(now())
  
  // Relations
  ticketId   String
  changedById String
  
  ticket     Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  changedBy  User   @relation(fields: [changedById], references: [id], onDelete: Cascade)

  @@map("history_items")
}

// Placeholder model for Intervention as it's a dependency of TestTask
model Intervention {
  id          String   @id @default(uuid())
  title       String
  description String?
  
  // Relations
  testTasks   TestTask[]
  tasks       Task[]
  
  @@map("interventions")
}

model TestTask {
  id                    String            @id @default(uuid())
  number                String            @unique
  name                  String
  description           String
  
  status                TestTaskStatus
  priority              TestTaskPriority
  
  startDate             DateTime?
  endDate               DateTime?
  dueDate               DateTime?
  estimatedTime         Int?
  actualTime            Int?
  
  testingEnvironment    String?
  hasBlocker            Boolean           @default(false)
  
  // Relations
  ticketId              String?
  interventionId        String?
  createdByUserId       String
  responsibleTesterId   String?

  ticket                Ticket?           @relation(fields: [ticketId], references: [id])
  intervention          Intervention?     @relation(fields: [interventionId], references: [id])
  createdBy             User              @relation("CreatedByTestTask", fields: [createdByUserId], references: [id])
  responsibleTester     User?             @relation("ResponsibleTesterTestTask", fields: [responsibleTesterId], references: [id])
  
  // Self-relation for subtasks
  parentTaskId          String?
  subtasks              TestTask[]        @relation("Subtasks")
  parentTask            TestTask?         @relation("Subtasks", fields: [parentTaskId], references: [id])
  
  // Join tables for many-to-many relations
  assignedTo            User[]            @relation("AssignedToTestTask")
  comments              TestTaskComment[]
  history               TestTaskHistory[]
  blockers              TestTaskBlocker[]

  @@map("test_tasks")
}

model TestTaskComment {
  id        String   @id @default(uuid())
  text      String
  createdAt DateTime @default(now())
  
  // Relations
  testTaskId String
  userId    String
  
  testTask  TestTask @relation(fields: [testTaskId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("test_task_comments")
}

model TestTaskHistory {
  id          String   @id @default(uuid())
  action      String
  timestamp   DateTime @default(now())
  details     Json? // Use JSON to store dynamic details
  
  // Relations
  testTaskId  String
  performedById String
  
  testTask    TestTask @relation(fields: [testTaskId], references: [id], onDelete: Cascade)
  performedBy User     @relation(fields: [performedById], references: [id], onDelete: Cascade)

  @@map("test_task_history")
}

model TestTaskBlocker {
  id          String   @id @default(uuid())
  reason      String
  description String?
  isResolved  Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  testTaskId  String
  reportedById String
  
  testTask    TestTask @relation(fields: [testTaskId], references: [id], onDelete: Cascade)
  reportedBy  User     @relation(fields: [reportedById], references: [id], onDelete: Cascade)

  @@map("test_task_blockers")
}


model Task {
  id                String            @id @default(uuid())
  number            String            @unique
  name              String
  description       String
  
  status            TaskStatus
  priority          TaskPriority      @default(LOW)

  ticketId          String?
  interventionId    String?
  projectId         String?
  assignedToId      String
  createdById       String
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  ticket            Ticket?           @relation(fields: [ticketId], references: [id])
  intervention      Intervention?     @relation(fields: [interventionId], references: [id])
  project           Project?          @relation(fields: [projectId], references: [id])
  assignedTo        User              @relation("AssignedToTask", fields: [assignedToId], references: [id])
  createdBy         User              @relation("CreatedByTask", fields: [createdById], references: [id])

  // Self-relation for subtasks
  parentTaskId      String?
  subtasks          Task[]            @relation("Subtasks")
  parentTask        Task?             @relation("Subtasks", fields: [parentTaskId], references: [id])
  
  // Join tables for many-to-many relations
  comments          TaskComment[]
  history           TaskHistory[]
  blockers          TaskBlocker[]
  attachments       Attachment[]

  @@map("tasks")
}

model TaskComment {
  id        String   @id @default(uuid())
  text      String
  createdAt DateTime @default(now())
  
  // Relations
  taskId    String
  authorId  String
  
  task      Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author    User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("task_comments")
}

model TaskHistory {
  id          String   @id @default(uuid())
  action      TaskHistoryAction
  timestamp   DateTime @default(now())
  details     Json? // Use JSON to store dynamic details
  
  // Relations
  taskId      String
  performedById String
  
  task        Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  performedBy User @relation("TaskHistoryPerformedBy", fields: [performedById], references: [id], onDelete: Cascade)

  @@map("task_history")
}

model TaskBlocker {
  id          String   @id @default(uuid())
  reason      String
  description String?
  isResolved  Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  taskId      String
  reportedById String
  
  task        Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  reportedBy  User @relation("TaskBlockerReportedBy", fields: [reportedById], references: [id], onDelete: Cascade)

  @@map("task_blockers")
}

model Attachment {
  id        String @id @default(uuid())
  filename  String
  url       String
  
  // Relations
  taskId    String
  commentId String?
  
  task      Task?    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  comment   TaskComment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

enum Role {
  client
  agent
  responsibleClient
  admin
  commercial
  projectManager
  groupLeader
  developer
  tester
}

enum TicketType {
  BUG
  FEATURE_REQUEST
  SUPPORT
  OTHER
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  REOPENED
  Draft
  Sent
  InProgressTicket // Added from ticket routes
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum TestTaskStatus {
  ToDo
  InProgress
  InReview
  Blocked
  Done
  Canceled
  Overdue
}

enum TestTaskPriority {
  LOW
  MEDIUM
  HIGH
}

enum TaskStatus {
  ToDo
  InProgress
  InReview
  Blocked
  Done
  Canceled
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}

enum TaskHistoryAction {
  created
  updated
  statusChanged
  assigned
  blocked
  unblocked
  commented
}

enum BillingMethod {
  hourly
  perTask
  subscription
}

enum AvailabilityDay {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}