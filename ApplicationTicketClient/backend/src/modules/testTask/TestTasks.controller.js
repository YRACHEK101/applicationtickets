import * as taskService from "../services/TestTasks.service.js";
import User from "../models/User.js";
import NotificationService from '../../../server/services/NotificationService.js'; 


export const getTask = async (req, res) => {
  try{
    const tasks = await taskService.getTask();
    res.json(tasks);
  }catch(error){
    res.status(400).json({
      success: false,
      message: error.message
    });
  }
};

export const getTaskById = async (req, res) => {
  try {
    const task = await taskService.getTaskById(req.params.id);
    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }

    // --- NEW LOGIC: Filter out null/undefined subtasks ---
    // Ensure task.subtasks exists and is an array before filtering
    if (task.subtasks && Array.isArray(task.subtasks)) {
      // Filter out any subtasks that are null or undefined
      // This handles cases where a subtask reference exists but the document doesn't
      task.subtasks = task.subtasks.filter(subtask => subtask !== null && subtask !== undefined);
    }
    // --- END NEW LOGIC ---
    
    res.json(task);
  } catch (error) {
    console.error("Get task error:", error);
    res.status(500).json({ message: "Server error" });
  }
};
export const getTasksByTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const tasks = await taskService.getTasksByTicketId(ticketId);
    
    res.status(200).json({
      success: true,
      count: tasks.length,
      data: tasks
    });
  } catch (error) {
    res.status(404).json({
      success: false,
      message: error.message
    });
  }
};
export const getTestingTasks = async (req, res) => {
  try {
    const tasks = await taskService.getAllTestTasks();
    res.json(tasks);
  } catch (error) {
    res.status(400).json({
      success: false,
      message: error.message
    });
  }
};

export const createTestTask = async (req, res) => {
  try {
    const taskData = req.body;
    const files = req.files;
    const userId = req.user.id;

    // Pass the taskNumber generated by multer to the service
    const taskNumberFromUpload = req.tempTaskIdentifier; // This is set in testTasks.routes.js
    

    const newTask = await taskService.createTestTask(taskData, userId, files, req.tempTaskIdentifier);

    res.status(201).json({
      success: true,
      data: newTask,
      message: "Test task created successfully"
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      message: error.message
    });
  }
};

export const updateTask = async (req, res) => {
  try {
    const updateData = req.body;
    const taskId = req.params.id;
    const currentUser = req.user; 

    const oldTask = await taskService.getTaskById(taskId);
    if (!oldTask) {
        return res.status(404).json({ message: "Task not found." });
    }
    
    if (updateData.assignedTo && !Array.isArray(updateData.assignedTo)) {
      updateData.assignedTo = [updateData.assignedTo];
    }
    
    const updatedTask = await taskService.updateTask(taskId, updateData, req.files);

    // --- Notification Logic for Admin Status Change ---
    if (currentUser.role === 'admin' && updateData.status && updateData.status !== oldTask.status) {
        const adminName = currentUser.lastName; 
        const newStatus = updatedTask.status; 
        const taskName = updatedTask.name; 

        // Get IDs of all assigned testers
        const assignedTesterIds = updatedTask.assignedTo.map(user => user._id.toString());

        if (assignedTesterIds.length > 0) {
            const message = `${adminName} a changé le statut de la tâche de test "${taskName}" à "${newStatus}".`;
            
            await NotificationService.createNotifications(
                assignedTesterIds, 
                message,
                updatedTask._id.toString(), 
                'TestTask' 
            );
        } else {
            console.log(`DEBUG: No testers assigned to task ${taskName}, skipping status change notification.`);
        }
    }


    res.json(updatedTask);
  } catch (error) {
    console.error("Update task error:", error);
    res.status(500).json({ message: "Server error" });
  }
};

export const addCommentToTask = async (req, res) => {
  try {
    const { text, mentions } = req.body;
    const taskId = req.params.id;
    const userId = req.user.id;

    if (!text) {
      return res.status(400).json({ message: "Comment text is required" });
    }

    const updatedTask = await taskService.addComment(taskId, userId, text, mentions, req.files);

    res.json(updatedTask);
  } catch (error) {
    console.error("Add comment error:", error); 
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

export const reportTaskBlocker = async (req, res) => {
  try {
    const {id: taskId } = req.params;
    const { reason, description } = req.body; 
    const userId = req.user.id;
    const userName = req.user.lastName; 
    
    // Add the blocker via the service
    const blocker = await taskService.addBlockerToTask({ taskId, reason, description ,userId });

    // Fetch the updated task to get its name
    const task = await taskService.getTaskById(taskId);
    if (!task) {
        return res.status(404).json({ message: "Test task not found after reporting blocker." });
    }

    // Get all admin user IDs
    const admins = await User.find({ role: 'admin' }).select('_id');
    const adminUserIds = admins.map(admin => admin._id.toString());

    // Get the ID of the user who reported the blocker (the tester themselves)
    const reporterUserId = userId;

    // Combine all recipient IDs (admins + reporter)
    const recipientIds = [...new Set([...adminUserIds, reporterUserId])];
   
    // Prepare notification data
    await NotificationService.notifyTestTaskBlockerReported(
        task._id.toString(), 
        task.name, 
        userName, 
        recipientIds
    );

    // Send the response for the blocker report
    res.status(200).json(blocker);  

  } catch (error) {
    console.error('Report task blocker error:', error);
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};